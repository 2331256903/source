<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  /* 操作DOM, 由于HTML文档被浏览器解析后就是一颗DOM树, 要改变HTML结构, 就需要通过JS来操作DOM
  *  始终记住DOM是一个树形结构, 操作一个DOM节点实际上就这么几个操作:
  *   更新: 更新该DOM节点的内容, 相当于更新了该DOM节点表示的HTML的内容
  *   遍历: 遍历该DOM节点下的子节点, 以便进行进一步操作
  *   添加: 在该DOM节点下新增一个子节点, 相当于动态增加了一个HTML节点
  *   删除: 将该节点从HTML中删除, 相当于删掉了该DOM节点的内容以及它所包含的所有子节点
  *  在操作一个DOM节点之前, 我们需要通过各种方式先拿到这个DOM节点, 最常用的方法就是 document.getElementById()和document.getElementByTagName(),
  * 以及CSS选择器document.getElementsByClassName()
  *  由于ID在HTML文档中是唯一的, 所以document.getElementById()可以直接定位唯一的一个DOM节点, document.getElementByTagName()和
  * document.getElementsByCLassName()总是返回一组DOM节点,要精确地选择DOM可以先定位父节点, 再从父节点开始选择,以缩小范围
  * */
  // 例如:
  // 返回ID为'test'的节点
  let test = document.getElementById('test')
  // 先定位ID为'test-table'的节点,再返回其内部的所有tr节点
  let trs = document.getElementById('test-table').getElementsByTagName('tr')
  // 获取节点test下的所有直属子节点
  let cs = test.children
  // 获取节点test下第一个,最后一个子节点
  let first = test.firstElementChild
  let last = test.lastElementChild

  /* 第二种方法是使用querySelector()和querySelectorAll(), 需要了解selector语法, 然后使用条件来获取节点, 更加方便*/
  // 通过querySelector获取ID为q1的节点
  let q1 = document.querySelector('#q1')
  // 通过querySelectorAll获取q1节点内的复合条件的所有节点
  let ps = document.querySelectorAll('div.highlighted > p')
  /* 注意: 低版本的IE<8不支持querySelector和querySelectorAll, IE8仅有限支持*/

  /* 严格来讲, 我们这里的DOM节点是指Element, 但是DOM节点实际上是Node, 在HTML中, Node包括Element,Comment,CDATA_SECTION等很多种,
  以及根节点Document类型, 但是绝大多数时候我们只关心Element, 也就是实际控制页面结构的Node, 其他类型的Node忽略即可,
  根节点Document已经自动绑定为全局变量document*/

  /* 注意: querySelectorAll返回的是一个NodeList对象, 而getElementsByClassName和getElementsByTagName返回一个HTMLCollection
  *   HTMLCollection随文档动态的变化,而NodeList没有按照动态的规则运行(非实时,如果添加节点,再次获取元素列表长度,不会刷新length)
  *
  *   NodeList是由Node.childNodes和document.querySelectorAll返回的,它有一个length属性,返回NodeList对象中包含的节点个数
  *   HTMLCollection接口包含了一个包含了元素的通用集合,它也有一个length属性值, 返回集合当中的子元素数目
  *   HTMLCollection做到了随着DOM元素的改变进行动态的变化, 而NodeList并不会即时更新元素集合中的值, 一个是静态的获取,一个是动态的获取
  *   同时动态的NodeList由于创建的过程中不需要任何操作,只需返回一个指针即可,不需要获取该节点的所有信息(此处可以理解为浅拷贝),
  * 因此速度远远快于需要遍历所有结果然后创造一个新的NodeList的querySelectorAll(此处可以理解为深拷贝)
  *   实际使用的过程中使用哪个方法取决于你要做什么, 如果只是查询一个tag name建议用getElementsByTagName 如果查询的是一个css selector则建议使用querySelectorAll
  * */
</script>
</body>
</html>
