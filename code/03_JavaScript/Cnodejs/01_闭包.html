<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
/* 闭包的定义: 从外部访问或者操作函数内部变量的方式, 缓存数据, 延长作用域链(JS中是函数作用域) */
/* 闭包表示的是一个封闭的内存空间, 每个函数被创建的时候都有一个与之关联的闭包 */
// 一个例子
function f() {
  let i = 1
  console.log(i, "f")
}
f()
/* 一旦f执行完毕, 那么它本次执行的栈上的数据将会被释放, 每次调用结束后, 栈上的i都会被及时释放 */

// 另一个例子
function f1() {
  let i = 0
  return function () { // f2
    console.log(i, "f1")
  }
}
let ff = f1()
ff()
/* 和第一个例子一样, 该代码同样打印0, 但这似乎打破了第一个例子的总结, 按照第一个例子的说法, f运行结束后本次调用栈上的i理应被释放掉了,但是随后调用
* 返回的匿名函数, 发现并没有报错, 这就归功于闭包 */
/* 每个函数创建的时候都会有一个与之关联的闭包被同时创建, 在新创建函数的内部, 如果引用了外部作用域的变量, 那么这些比那辆都会被添加到该函数的闭包中 */
/* 注意上面代码的注释, 为了方便将匿名函数取名为f2, 当f被调用时f2被创建, 同时与之关联的闭包也被创建, 由于f2内部引用了位于其作用域之外的f作用域
* 之中的变量i, 因此f作用域中的i被拷贝到了f2的闭包中, 这就解释了为什么f执行完成后, 调用f2依然可以打印0 */

// 再看一个例子
function f2() {
  let i = 0
  function f3() {
    console.log(i, "f2")
  }
  i = 1
  return f3
}
let ff2 = f2()
ff()
/* 我们发现会打印1, 好像又和第二个例子的结论有些冲突, f2中的i不是被拷贝到了f3的闭包中了吗, 为什么不是打印0而是打印1呢 */
/* 这与闭包发生拷贝的时机有关, 如果创建新的函数, 引用了外部作用域的变量, 并且该变量为活动的, 那么就不会急于将该变量的内容拷贝到闭包中,
而是将该变量所指向的内存单元的地址保存与闭包中, 比如这里只是先将i绑定到的内存地址保存于闭包中, 等到i为非活动状态时才会进行拷贝, 也就是这里当f即将
运行结束时, i将变非活动状态, 那么需要将其内容拷贝到引用它的闭包中, 也就是这里的f3的闭包中, 一旦内容被拷贝到闭包中, 除了与之关联的对象之外再也没有
其他方式可以访问到其中内容*/
/* 闭包中占用的内存在与它关联的函数对象被释放的时候会被释放 */
ff = null
/* 将引用f1的变量ff赋值为null, 这样就没有任何变量引用f1了, 所以f1成为了垃圾, 会在未来的某个时间点(具体要看GC的实现和运行情况),由垃圾回收器进行
所占内存的回收 */

// 复杂版的例子
function f4() {
  var a = []
  for (var i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i, "f4")
    }
    a.push(ff)
  }
  return a
}
const [f5, f6] = f4()
f5()
f6()
/* 这里运行的两个函数都会打印2(原因在于循环变量i用var定义, 已经很熟悉了), 新创建的函数引用外部作用域上的变量内容, 最终都会拷贝到该函数的闭包中,
* 那么上面的例子i是否被拷贝了两次 */
// 再看一个更复杂的例子
function f7() {
  var a = []
  for (var i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i, "f7")
    }
    a.push(ff)
  }
  a.push(function () {
    i++
  })
  return a
}
const [f8, f9, f10] = f7()
f8()
f10()
f9()
// 再次使用f8
f8() // 打印3, 共享同一个变量i
/* 这个例子打印了2和3, 这是因为闭包的另一个机制, 同一个变量被引用它的多个闭包所共享, 我么在for循环内部创建了两个函数, 在循环外部创建了一个函数,
* 这三个函数都引用了f7中的i, 因而i被这三个函数的闭包所共享, 也就是说i在离开自己所属的作用域时(f7退出前)将只会发生一次拷贝, 并将新创建的三个函数的
* 闭包中的i的对应的指针设定为那一份拷贝的内存地址即可, 对于这一个共享的拷贝地址, 除了这三个闭包之外没有其他方式可以访问到它*/
/* f7()退出时只发生一次拷贝, 三个函数共享变量i, 故打印2 3 */
/* 必须再次强调的是, 被引用的变量拷贝到闭包中的时机发生在: 被引用的变量离开自己所属的作用域时, 即状态为非活动时 */

// 再看一个例子, for循环体使用let定义i
function f11() {
  const a = []
  for (let i = 0; i < 2; i++) {
    var ff = function () {
      console.log(i, "f11")
    }
    a.push(ff)
  }
  return a
}
const [f12, f13] = f11()
f12()
f13()
/* ES6开始引入了let关键字, 由它声明的变量属于块级作用域, 上述例子中, for循环体初始化部分使用let, 这样以来i的作用域被设定为了该循环的块级作用域内,
* 不过另一个细节是, 循环体中的i的作用域是每一次的迭代, 因此在循环体中, 当每次迭代的i离开作用域时吗, 它的状态变为非活动的, 因此它的内容被拷贝到引用它的闭包中 */

/* 闭包常和IIFE(立即执行函数)一起使用 */
var a = []
for (var i = 0; i < 2; i++) {
  a.push((function(i) { // f1 i1
    return function () { // f2
      console.log(i, "IIFE") // i2
    }
  })(i)) // i3
}
const [f14, f15] = a
f14()
f15()
/* 上述例子中:
*   i1 是 f1 的形参
*   i2 是 f2 中对外层作用域中的变量的引用
*   i3 是全局的变量 i, IIFE执行时 i 对应的值将被作为实参来调用 f1
*   当 f1 被调用时, 也就是IIFE执行阶段, 它的内部创建了一个新的函数f2, 同时也创建了f2对应的闭包
*   由于 f2 中引用了外层作用域中的 i, 即 f1 执行期间的 i, 且 i 为活动内容, 所以 f2 的闭包中添加一条 Key 为 i ,Value 为指向 f1 中活动的 i
* 绑定到的内存单元的地址
*   当IIFE执行完毕, 即 f1 要退出的时候, 其栈上活动对象 i 就会离开作用域, 因此需要将 i 拷贝到它的闭包中
*  */

// 目前为止看到的例子都是引用的直接外层作用域中的变量, 再看一个例子
function f16(x) { // f1
  return function (y) { // f2
    return function (z) { // f3
      console.log(x + y + z, "f16")
    }
  }
}
const xy = f16(1)
const xyz = xy(2)
xyz(3)
/* 在 f3 内部引用了 x 和 y, 并且 x 并不是 f3 的直接外部作用域, 那么这个闭包的构建过程如何 */
/* JS中函数也是以对象的形式存在的, 如果将与函数关联的闭包想象成函数对象的一个类型为Map<String, Value>的属性也不过分 */
// 例如
const CLOSURE = Symbol('closure')
const FUN_BODY = Symbol('fun-body')
const FUN_PARAMS = Symbol('fun-params')
const funObj = {
  [FUN_PARAMS]: [/* parameters list */],
  [FUN_BODY]: [/* instructions */],
  [CLOSURE]: new Map(String, Value), // Value可以被多个closure共享
}
/* 即使在引擎的实现阶段, 因为性能或者实现差异不采用这样的设计, 但本质上与这个结构含义是一致的, 为了能在运行阶段创建函数对象, 在编译阶段接需要收集到必要的信息:
*   形参列表  函数体  引用的外部变量
*  比如在编译f3的阶段, 我们发现了它内部引用了外部的 x 和 y, 由于 x 不是直接存在于父级作用域 f2 中, 为了是的未来使用f2 创建 f3 的时候,
* 仍然能找到 x 的绑定, 我们需要将 x 加入到 f2 的闭包中, 所以在编译阶段, 我们会在 f2 的信息中标注它引用了外部变量 x, 这样创建 f2 的时候,
* x 就会被拷贝到它的闭包中了, 等到使用它再创建 f3 的时候, f3 中的 x 也就有了着落
*  */
</script>
</body>
</html>
