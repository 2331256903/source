<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  /* setTimeout定时器第一个参数是到时间后执行的代码块, 第二个参数是延迟时间()毫秒, 第三个以及之后的参数都作为回调函数的参数 */
   // 此处setTimeout的返回值是一个定时器的编号, 是一个整数
  /*var timer = setTimeout(function() {
    console.log(timer)
  }, 1000)*/
	
	/* 此处字符串会被执行两次解析, 当前字符串会被编译成函数, 函数再执行, 造成浏览器的负担 */
	// 字符串传参的方式
	/*var timer = setTimeout("console.log(timer);", 1000)*/
	
	/* 同步任务优先执行, 异步任务滞后执行 */
	/* 此处不传递第二个参数延迟时间,则延时4毫秒执行, html5中规定浏览器执行时延时默认不低于4毫秒 */
	var timer = setTimeout(function() {
		console.log(timer)
	})
	console.log("start")
	// start 1

	var timer1 = setTimeout(function() {
		console.log(timer1) // 1
	},3)
	var timer2 = setTimeout(function() {
		console.log(timer2) // 2
	},2)
	var timer3 = setTimeout(function() {
		console.log(timer3) // 3
	},1)
	// 按照上面的理论应当按照注册顺序执行, 但是实际上输出的还是 3, 2, 1  因为虽然规定延迟不低于4ms,但浏览器能识别到3,2,1ms


	var timer_1 = setTimeout(function() {
		console.log(timer_1) // 1
	},0.3)
	var timer_2 = setTimeout(function() {
		console.log(timer_1) // 2
	},0.2)
	var timer_3 = setTimeout(function() {
		console.log(timer_3) // 3
	},0.1)
	// 此时输出按照注册顺序输出1,2,3  此时浏览器无法识别0.1,0.2,0.3, 就按照该浏览器的最低时间间隔来执行, 不同浏览器结果不同
	
	/* 各大浏览器厂商基本采取两种策略
	* 		首先会在延迟时间和1ms中取一个最大值, 即在不满足嵌套层级的情况下, 最小延迟时间先设置为1ms
	* 		如果设置的timeout小于0, 则设置为0
	* 		如果嵌套的层级超过了5层, 并且timeout小于4ms, 则设置timeout为4ms
	* 		chrome和safari中最小时间为1ms, 而firefox 65.0.1和 IE11的最小延迟时间为0
	*  */
</script>
</body>
</html>
