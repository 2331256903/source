<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  /**
   * String 对象属性
   * constructor 对创建该对象的函数的引用
   * length 字符串的长度
   * prototype 允许向对象添加属性和方法
   * */

  /**
   * String 对象方法
   * 1. string.charAt(index) 返回在index位置的字符, 第一个字符index为0
   *  eg: let str = "HELLO WORLD"
   *      let n = str.charAt(2) // L
   *
   * 2. string.concat(str1, str2, ..., strX) 连接两个霍更多字符串并返回新的字符串, 方法不改变原字符串
   *  eg: let str1 = "Hello "
   *      let str2 = "world!"
   *      let n = str1.concat(str2) // Hello world!
   *
   * 3. string.endsWith(searchValue, length) 区分大小写判断当前字符串是否是以指定的子字符串结尾,返回boolean; length设置字符串的长度, 默认为string.length
   *  eg: let str = "Hello World"
   *      str.endsWith("World", 5) // false
   *
   * 4. string.indexOf(searchValue, start) 返回某个指定的字符串值在字符串中首次出现的位置,没找到返回-1
   *  eg: let str = "Hello world, welcome to the universe"
   *      let n = str.indexOf("welcome") // 13
   *
   * 5. string.includes(searchValue, start) 区分大小写判断字符串是否包含指定的子字符串, 返回boolean
   *  eg: let str = "Hello world, welcome to the Runoob."
   *      let n = str.includes("world", 12) // false 从第12个索引位置开始查找字符串
   *
   * 6. string.match(regexp) 在字符串内检索指定的值, 找到一个或多个正则表达式的匹配
   *  注意: match() 方法将检索字符串String Object, 以找到一个或多个与regexp匹配的文本, 这个方法的行为很大程度上依赖于regexp是否带全局匹配标志g,
   *  如果没有则只在String Object中执行一次匹配, 如果没有找到任何匹配的文本, 则返回null, 否则它返回一个数组, 其中存放了与它找到的匹配文本有关的信息
   *  eg: 全局查找字符串"ain", 且不区分大小写
   *      let str = "The rain in SPAIN stays mainly in the plain"
   *      let n = str.match(/ain/gi) // ain, AIN, ain, ain
   *
   * 7. string.repeat(count) 字符串复制指定count次数
   *  eg: let str = "Runoob"
   *      str.repeat(2) // RunoobRunoob
   *
   * 8. string.replace(searchValue, newValue) 用于在字符串中用一些字符替换另一些字符, 或替换一个与正则表达式匹配的子串
   *  eg: let str = "Mr Blue has a blue house and a blue car"
   *      let n = str.replace(/blue/gi, "red") // Mr red has a red house and a red car
   *
   * 9. string.search(searchValue) 用于检索字符串中指定的子字符串, 霍检索与正则表达式相匹配的子字符串, 未找到字符串返回-1
   *  eg: let str = "Mr. Blue has a blue house"
   *      document.write(str.search(/blue/i)) // 4
   *
   * 10. string.slice(start, end) 可提取字符串的某个部分,并返回新字符串, 参数为负数表示从尾部 截取多少字符串
   *  eg: let str = "Hello, world!"
   *      let n = str.slice(-2)  // d!
   *
   * 11. string.split(separator, limit)
   *  separator 可选,字符串或正则表达式, 从该参数指定的地方分割String Object
   *  limit 可选,该参数可指定返回的数组的最大长度, 如果设置了该参数, 返回的子串不会多于这个参数指定的数组, 如果没有设置改参数, 整个字符串都会被分割,不考虑它的长度
   *  返回值: 一个字符串数组, 该数组是通过在separator指定的边界处将字符串String Object分割成子串创建的, 返回的数组中的子串不包括separator自身
   *    eg: let txt = "apple,banana,orange"
   *        let fruits = txt.split(",") // 分隔符为逗号  ["apple", "banana", "orange"]
   *    eg2: 使用正则表达式
   *        let txt = "apple banana orange"
   *        let fruits = txt.split("/\s+/") // 使用正则表达式匹配一个或多个空白字符 ["apple", "banana", "orange"]
   *    eg3: 使用参数limit
   *        let txt = "apple,banana,orange"
   *        let fruits = text.split(",", 2) // 只取前两个结果 ["apple", "banana"]
   *    eg4: 空字符串和空正则作为分隔符
   *        当split方法的分隔符是空字符串时, 字符串会被拆分成单个字符数组
   *        let txt = "hello"
   *        let characters = text.split("") // ["h", "e", "l", "l", "o"]
   *  注: 对于大型字符串或需要频繁执行拆分操作的场景, 使用复杂正则表达式可能显著增加处理时间, 重用已经创建的正则表达式对象而不是在每个split调用中创建新实例,可能显著提升性能
   *
   * 12. string.substr(start, length) 在字符串中抽取从start下标开始指定数目的字符, substr()的参数指定的是子串的开始位置和长度, 因此可以替代substring()和slice()来使用
   *  eg: let str = "Hello world"
   *      let n = str.substr(2) // llo world
   *
   * 13. string.trim() 去除字符串的头尾空格
   *  eg: let str = " Runoob     "
   *      let n = str.trim() // Runoob
   *  注: trim()方法用于删除字符串的头尾空白符, 包括空格,制表符tab,换行符等其他空白符
   *      trim()方法不会改变原始字符串
   *      trim()方法不适用于null, undefined, Number类型
   *
   * 14. string.valueOf() 方法返回String对象自身(对象的原始值) 该方法通常在后台自动进行调用而不是显式地处于代码中
   *     string.toString() 方法返回一个表示String对象的值
   *     注: 对于字符换转换, 优先调用toString方法, 然后在调用valueOf方法
   *     一个对象被转换到字符串的时候, 首先隐式调用toString()方法, 尝试如果能够返回出基本数据类型(字符串,数组,布尔值等),则可以调佣String()函数
   *   继续转换该值,最终返回出字符串; 但如果toString()方法返回出来不是基本数据类型,依然是一个对象,那么再继续调用ValueOf()方法,如果返回出来的是基本数据类型,然后再继续用String()函数转换该值
   *     而如果这两个方法都返回对象类型,浏览器基本会报错提示无法将对象转换为字符串值
   * */

  /**
   * Array对象属性
   * constructor 返回创建数组对象的原型函数
   * length 设置或返回数组元素的个数
   * prototype 允许向数组对象添加属性或方法
   * */

  /**
   * Array对象方法
   * 1. array1.concat(array2, array3, ..., arrayX) 用于连接两个或多个数组, 该方法返回一个新数组
   *  eg: const arr1 = ["a", "b", "c"]
   *      const arr2 = ["d", "e", "f"]
   *      arr3 = arr1.concat(arr2) // ["a", "b", "c", "d", "e", "f"]
   *
   * 2. array.entries() 返回一个数组的迭代对象,该对象包含数组的键值对, 迭代对象中数组的索引值为key, 数组元素作为value
   *  eg: let fruits = ["Banana", "Orange", "Apple", "Mange"]
   *      fruits.entries() // {[0, "Banana"], [1, "Orange"], [2, "Apple"], [3. "Mango"]}
   *
   * 3. array.every(function(currentValue, index, arr), thisValue)
   *  every()方法用于检测数组所有元素是否都符合指定条件(通过函数提供)
   *  every()方法使用指定函数检测数组中的所有元素
   *    如果数组中检测到有一个元素不满足, 则整个表达式返回false, 且剩余的元素不会再进行检测
   *    如果数组中所有元素都满足条件, 则返回true
   *   注: every()不会对空数组进行检测, every()不会改变原始数组
   *  function参数说明:
   *    currentValue: 必选,当前元素的值
   *    index: 可选, 当前元素的索引值
   *    arr: 可选, 当前元素属于的数组对象
   *  thisValue: 可选, 对象作为执行回调时使用, 传递给函数, 用作this的值, 如果省略了thisValue, this的值为undefined
   *  eg: let ages = [32, 33, 16, 40]
   *      function checkAdult(age) {
   *          return age >= 18
   *      }
   *      function myFunction() {
   *          args.every(checkAdult) // false
   *      }
   *
   * 4. array.fill(value, start, end) 用于将一个固定值替换数组的元素
   *  eg: let fruits = ["Banana", "Orange", "Apple"]
   *      fruits.fill("Runoob", 2, 3) // ["Banana", "Orange", "Runoob"]
   *
   * 5. array.filter(function(currentValue, index, arr), thisValue) 创建一个新的数组, 新数组中的元素是通过检查指定数组中符合条件的所有元素
   *  参考every()方法, 区别是filter会返回一个过滤后的数组
   *   eg: let ages = [32, 33, 16, 40]
   *      function checkAdult(age) {
   *          return age >= 18
   *      }
   *      function myFunction() {
   *          args.filter(checkAdult) // [32, 33, 40]
   *      }
   *
   * 6. array.forEach(callbackFn(currentValue, index, arr), thisValue) 用于调用数组的每个元素, 并将元素传递给回调函数
   * 总结: JS数组遍历方法: forEach, map, filter, reduce, some, every
   * 1). forEach: 对数组中的每个元素执行指定的回调函数, 没有返回值
   *  array.forEach((element, index, array) => {
   *      // 执行操作
   *  })
   * 2). map: 对数组中的每个元素执行指定的回调函数, 并返回一个新数组, 新数组由每个元素经过回调函数处理后的结果组成
   *  const newArray = array.map((currentValue(当前元素), index(当前索引), arr(原始数组)) => {
   *      // 返回处理后的结果
   *  })
   * 3). filter: 根据指定的条件过滤数组中的元素, 返回一个新的数组, 新数组只包含满足条件的元素
   *  const newArray = array.filter((element, index, array) => {
   *      // 返回累积的结果
   *  }, thisValue) // thisValue可选,对象作为该执行callback时传递给函数, 用作this的值, 若省略该值则this的值为undefined
   *
   * 4). reduce: 通过遍历数组将其元素累积为单个值, 接受一个回调函数和一个初始值作为参数, 返回累积的结果
   * 接受一个函数作为累加器,数组中的每个值从左到右开始缩减,最终计算为一个值
   * const result = array.reduce((prev(必选,第一次使用initialValue的值(无initialValue则使用array[0]) || 上次callbackFn的返回值), cur(必选,数组当前被处理的元素), index, array(可选,调用reduce的数组)) => {
   *     // 返回累积的结果
   * }, initialValue)
   * 注意: 每次回调一定要返回一个值,否则后续会变成undefined或NaN
   * eg: let arr = [1,2,3,4,5]
   *     let sum = arr.reduce(function (prev, cur, index, arr) => {
   *         console.log(prev, cur, index)
   *         return prev + cur
   *     })
   *     console.log('arr:', arr, 'sum:', sum)
   *
   *     // 1 2 1
   *     // 3 3 2
   *     // 6 4 3
   *     // 10 5 4
   *
   * 5). some: 检查数组中是否至少有一个元素满足指定的条件, 返回一个布尔值
   *  const hasSome = array.some((element, index, array) => {
   *      // 返回条件判断结果
   *  })
   * 6). every: 检查数组中是否所有元素都满足指定的条件, 返回一个布尔值
   *  const allMatch = array.every((element, index, array) => {
   *      // 返回条件判断结果
   *  })
   *
   * 方法的区别:
   * forEach()没有返回值, 它仅用于遍历数组并对每个元素执行操作
   * map()返回一个新的数组, 该数组由原始数组中的每个元素经过回调函数处理后的结果组成
   * filter()返回一个新的数组, 该数组有原始数组中满足指定条件的元素组成
   * reduce()返回一个累积的结果, 该结果可以是任意类型的值
   * some()返回一个布尔值, 表示数组中是否至少有一个元素满足指定条件
   * every()返回一个布尔值, 表示数组中的所有元素是否都满足指定条件
   * 修改原数组:
   * forEach(),map(),filter(),some(),every()方法不会修改原数组,只对数组进行遍历或条件判断
   * reduce()方法可以通过累积的过程修改原始数组的值, 但需要在回调函数中显式地操作
   * 返回新数组:
   * map(),filter()方法返回一个新数组而不会修改原始数组
   *
   * 7. array.from(object(必选,要转换为数组的对象), mapFunction(可选,数组中每个元素要调用的函数), thisValue) 通过拥有length属性的对象或可迭代的对象来返回一个数组,吐过对象是数组返回true,否则返回false
   * eg: let arr = Array.from([1, 2, 3], x => x * 10)
   * // arr[10, 20, 30]
   * eg2: 利用Set和from实现数组去重
   * let arr = Array.from(new Set([1, 2, 1, 2]))
   * eg3: 将伪数组转换为数组
   * let obj = {
   *     '0': 1 // '0'将转换为下标0,后续key同理
   *     '1': 2
   *     '2': 3
   *     'length': 4 // length规定转换的数组长度
   * }
   * let newObj = Array.from(obj, item => item) // [1, 2, 3, undefined]
   *
   * 8. array.join(separator) 用于把数组中的所有元素转换为一个字符串, 元素通过指定的分隔符进行分割
   *
   * 9. array.push(item1, item2, ..., itemX) 向数组末尾添加一个或多个元素
   *
   * 10. array.pop() 删除数组最后一个元素并返回删除的元素
   * 11. array.shift() 用于把数组的第一个元素从其中删除,并返回第一个元素的值
   * 12. array.reverse() 颠倒数组顺序
   *
   * 13. array.slice(start, end) 从已有数组中返回选定的元素, 包含从start(包含)到end(不包括该元素)的arrayObject中元素, slice()方法不会改变原始数组
   *  start: 可选, 规定从何处开始选取, 若该参数为负数, 则表示从原数组中的倒数第几个元素开始,slice(-2)表示提取原数组中的倒数第二个元素到最后一个元素(包含最后一个元素)
   *  end: 可选, 规定从何处结束选取, 该参数是数组片段结束处的数组下标,如果没有指定该参数,那么切分的数组包含从start开始到结束的所有元素, 若该参数为负数
   * ,则它表示在原数组中的倒数第几个元素结束抽取, slice(-2, -1)表示抽取了原数组中的倒数第二个元素到最后一个元素(不包含), slice(0, -1)表示截取从第一个(包含)到倒数第一个元素(不包含)
   *
   * 14. array.sort(sortFunction) 用于对数组的元素进行排序
   * 注: 1. 排序顺序可以是字母或数字. 并按升序或降序排序
   *    2. 默认排序顺序是按字母升序
   *    3. 当数字是按字母顺序排列时, "40"会排在"5"前面
   *    4. 使用数字排序必须通过一个函数作为参数来调用
   *    5. 这种方法会改变原始数组
   * eg: 数字升序
   *  let points = [40, 100, 1, 5, 25, 10]
   *  points.sort((a, b) => a - b)
   * 注2: sort()方法回调函数
   *  回调参数有a,b两个, 在chrome/ie/edge浏览器中参数b始终在参数a的前面, 该方法的排序是看回调函数的返回值:
   *  1). 返回值小于0, 则位置互换
   *  2). 返回值大于0, 则位置不变
   *  eg: let arr = [9, 7, 2]
   *      arr.sort(function(a, b) {
   *          if(a > b)
   *            return 1
   *          else
   *            return -1
   *      })
   *      此处第一次比较a > b, 比较 7 > 9, 此时为false, return -1, a, b位置互换
   * 注3: 其实不同浏览器对该sort()排序的方法不同, 火狐使用归并排序, 谷歌使用改进版快速排序
   *  在火狐中,a在前b在后; 而在谷歌/ie/edge,a在后b在前; 因此在实现排序效果时不需要关注a,b, 升序返回a-b, 降序返回b-a
   *
   * 15. array.splice(index(必传,规定从何处添加/删除元素), howMany(可选,规定删除多少元素,不传则删除从index开始到原数组结尾所有元素), item1, item2, ... itemX(可选,要添加到数组的新元素))
   *  eg: 移除数组的第三个元素, 并在数组的第三个位置添加新元素
   *      let fruits = ["Banana", "Orange", "Apple", "Mango"]
   *      fruits.splice(2, 1, "Lemon", "Kiwi") // [Banana,Orange,Lemon,Kiwi,Mango]
   *
   * 16. array.toString() 将数组转换为字符串, 并返回结果, 数组中的元素之间用逗号分隔
   *  eg: let fruits = ["Banana", "Orange", "Apple", "Mango"]
   *      fruits.toString() // "Banana,Orange,Apple,Mango"
   * */

  /**
   * Object.prototype
   * 1. Object.getOwnPropertyNames()
   *  返回一个数组, 成员是参数对象本身的所有属性的键名, 不包含继承的属性键名
   * 2. Object.hasOwnProperty()
   *  返回一个布尔值, 用于判断某个属性定义在对象自身还是定义在原型链上
   * 3. Object.isPrototypeOf()
   *  返回一个布尔值, 用于判断该对象是否为参数对象的原型
   * 4. in运算和for...in循环
   *  in运算返回一个布尔值, 表示一个对象是否具有某个属性, 它不区分该属性是对象自身的属性还是继承的属性
   *  'length' in Date // true
   *  for...in获得对象的所有可遍历属性(不管是自身还是继承的)
   *  let o2 = Object.create({p1: 123}, p2: {value: "abc", enumerable: true})
   *  for(p in o2) {console.log(p)} // p1 p2
   * ES6新增
   * 1. Object.is() 用来比较两个值是否严格相等, 与严格比较运算符===的行为基本一致
   * 2. Object.assign() 用于对象的合并, 将源对象的所有可枚举属性,复制到目标对象target
   *  注: 1.如果目标对象与源对象有同名属性, 或多个源对象有同名属性, 则后面的属性会覆盖前面的属性
   *      2.assign() 实行浅拷贝, 如果源对象某个属性的值是对象, 那么目标对象拷贝得到的是这个对象的引用
   * 3. Object.getOwnPropertyDescriptors() 返回指定对象所有自身属性(非继承属性)的描述对象
   * 4. Object.setPropertyOf() 作用等同于__proto__, 用来设置一个对象的prototype,返回参数对象本身
   * 5. Object.getPrototypeOf(obj) 该方法与Object.setPrototypeOf()配套, 用于查询读取一个对象的原型对象
   * 6. Object keys(), Object.values(), Object.entries() 三个方法都是将对象中的键或者值转换成数组可供遍历, ES2017引入了与Object.keys配套
   * 的Object.values()和Object.entries()作为遍历对象的补充手段, 供for...of循环使用
   * */
</script>
</html>
