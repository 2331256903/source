<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

</body>
<script>
  /*JavaScript变量可以是局部变量或全局变量,私有变量可以用到闭包*/
  function myFunction(){
    let a = 4
    return a*a
  }

  let a = 4
  function myFunction2(){
    return a*a
  }
  /*后一个实例中,a是一个全局变量,在web页面全局变量书属于window对象,全局变量可以应用于页面上的所有脚本*/
  /*第一个实例中,a是一个局部变量,局部变量只能用于定义它的函数内部,对于其他的函数或者脚本代码是不可用的*/
  /*全局和局部变量即使名称相同也是两个不同的变量,修改其中一个不会影响到另一个的值*/
  /*函数内内部声明的变量只在函数内部起作用,局部变量作用域是局部的,函数的参数也是局部性的,只在函数内部起作用*/

  /*JS内嵌函数*/
  /*JS中 所有函数都能访问它们上一级的作用域,支持嵌套函数,嵌套函数可以访问它们上一级层的函数变量*/
  function add (){
    let counter = 0
    function plus() {counter++ }
    plus()
    return counter
  }
  /*如果能在外部访问plus函数,就能解决计数器困境,需要闭包*/
  let add2 = (function(){
    let counter = 0
    return function () {return counter += 1}
  })()
  add2()
  add2()
  add2() //计数器为3
  /*此处第一个function为自调用函数,只执行了一次并定义了变量counter=0
  * 实际上add2 = function(){return counter += 1},但次函数可以访问到counter
  * JS闭包,使得函数可以拥有私有变量
  * 计数器收到匿名函数的作用域保护,只能通过add方法修改
  * */

  /*闭包是一个函数引用另一个函数的变量,由于变量被引用着所以不会被回收,因此可以用来封装一个私有变量,
  但缺点是不必要的闭包会增加内存消耗,如果一个函数访问了此函数的父级以及父级以上的作用域变量,那么这个函数就是一个闭包*/
  /*实现闭包的最常见方式是函数嵌套(不是唯一方式)*/

  /*模拟面向对象的代码风格*/
  function person(name){
    /*此处的函数say访问了父级函数person中的局部变量name,形成了一个闭包
    * 函数内部的变量对外是无法访问的,闭包通过这种变通的方法实现了访问
    * */
    return function say(content){
      console.log(name+ ':' + content)
    }
  }
  /*person函数只在初始化时执行一次*/
  a = person("张三")
  b = person("李四")
  a("在干嘛")
  b("摸鱼")

  /*闭包的优点:
  *   减少全局变量的定义,避免全局变量的污染
  *   能够读取函数内部的变量
  *   在内存中维护一个变量,可以用作缓存
  * 闭包的缺点:
  *   造成内存泄漏:闭包会使函数中的变量一直保存在内存中,内存消耗跟打,不能滥用闭包,否则会造成网页的性能问题,在IE中可能导致内存泄漏
  *     解决方法:使用完变量后将其手动赋值null
  *   闭包可能在父函数外部改变父函数内部变量的值
  *   造成性能损失:由于闭包设计跨作用域的访问,所以会导致性能损失
  *     解决方法:通过把夸作用域变量存储在局部变量中,然后直接访问局部变量来减轻对执行速度的影响
  * */
</script>
</html>
