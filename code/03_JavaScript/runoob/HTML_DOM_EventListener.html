<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<p id="demo"></p>
<button id="Btn">点我</button>
</body>
<script>
/*
* 在用户点击按钮时触发监听事件:
*   document.getElementById("myBtn").addEventListener("click",displayDate)
*   addEventListener()方法用于向元素添加事件句柄,添加的事件句柄不会覆盖已存在的事件句柄
*   可以向一个元素添加多个事件句柄,也可以向同个元素添加多个同类型的事件句柄,如两个onclick
*   addEventListener()方法可以更简单的控制事件(冒泡与捕获)
*   使用removeEventListener()来移除事件的监听
* */

/*element.addEventListener(event,function(){},useCapture)*/
/*
* 第一个参数是事件的类型,click或mousedown等
* 第二个参数是事件触发调用后的函数
* 第三个参数是个布尔值用于描述事件是否冒泡还是捕获,该参数可选
* */

/*向window对象添加事件句柄*/
window.addEventListener("resize",function(){
  document.getElementById("demo").innerHTML = Math.random()
})
/*传递参数*/
let p1 = 5,p2 = 10
document.getElementById("Btn").addEventListener("click",function (){myFunction(p1,p2)})
function  myFunction(a,b){
  let result = a*b
  document.getElementById("demo").innerHTML = result
}

/*
* 事件冒泡或事件捕获:
*   事件传递有两种方式:冒泡或捕获
*   事件传递定义了元素事件触发的顺序,eg将<p>元素插入<div>元素中,哪个元素的click事件被触发
*     在冒泡中内部元素先被触发,再触发外部元素
*     在捕获事件中先触发外部元素再触发内部元素的点击事件
* */
document.getElementById("myDiv").addEventListener("click",myfunction,true)

/*跨浏览器解决方法*/
let x = document.getElementById("MyBtn")
if(x.addEventListener){
  x.addEventListener("click",myFunction)  //所有主流浏览器,除了IE8以及更早版本
}else if(x.attachEvent){
  x.attachEvent("onclick",myFunction)  //IE8以及更早版本
}
</script>
</html>
