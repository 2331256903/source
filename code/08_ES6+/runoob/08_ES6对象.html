<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
/* 对象字面量
*   属性的简洁表示法 ES6允许对象的属性直接写变量, 这时候属性名是变量名, 属性值是变量值
*  */
const age = 12
const name = "Miko"
const person = {age, name} // 等效于const person = {age: age, name: name}
console.log(person)
// 方法名也可以简写
const person2 = {
  sayHi() {
    console.log("Hi")
  }
}
/* 等效于
*   const person2 = {
*     sayHi: function() {
*       console.log("Hi")
*     }
*   }
*  */
// 如果是Generator函数则需要在前面加一个星号*

/* 属性名表达式
*   ES6允许用表达式作为属性名, 但是一定要将表达式放在方括号内
* 注意: 属性的简洁表示法和属性名表达式不能同时使用
*  */
const obj = {
  ["he"+"llo"]() {
    return "Hi"
  }
}
obj.hello() // Hi

/* 对象的扩展运算符
*   扩展运算符(...) 用于取出参数对象的所有可遍历属性然后拷贝到当前对象
*  */
// 基本用法
let person3 = {name: "Amy", age: 15}
let someone = { ...person3 }
console.log(someone) //{name: "Amy", age: 15}
// 可用于合并两个对象
let age2 = {age: 15}
let name2 = {name: "Amy"}
let person4 = {...age2, ...name2}
console.log(person4) //{age: 15, name: "Amy"}
/* 注意: 自定义的属性和扩展运算符对象里的属性相同的时候, 自定义的属性在扩展运算符后面, 则扩展运算符对象内部同名的属性将被覆盖 */
let someone2 = {...person, name: "Miko", age: 17}
// 自定义的属性在扩展运算符前面, 则变成设置新对象默认属性值
// 扩展运算符后面是空对象或null或undefined, 没有任何效果也不会报错

/* 对象的新方法
*   Object.assign(target, source_1, ...) 可以用于将源对象的所有可枚举属性复制到目标对象中
*  */
// 基本用法
let target = {a: 1}
let object2 = {b: 2}
let object3 = {c: 3}
Object.assign(target, object2, object3)
// 第一个参数是目标对象, 后面的参数是源对象
console.log(target) // {a: 1, b: 2, c: 3}
/* 注意: 如果目标对象和源对象有同名属性, 或者多个源对象有同名属性, 则后面的属性会覆盖前面的属性
*       如果该函数只有一个参数, 当参数为对象时, 直接返回该对象, 当参数不是对象时, 会先将参数转为对象然后返回, 而由于null和undefined不能转化为对象, 所以会报错
*       assign的属性拷贝是浅拷贝
*  */
// 数组的处理
Object.assign([2, 3], [5]) //[5, 3]
// 由于assign会将数组处理成对象, 所以先将[2, 3]转化成{0: 2, 1: 3}, 然后在进行属性复制, 所以源对象的0号属性覆盖了目标对象的0号属性

/* Object.is(value1, value2)
*   用来比较两个值是否严格相等, 与===基本类似, 区别为 Object.is(+0, -0)为false, 而Object.is(NaN, NaN)是true
* */
</script>
</body>
</html>
